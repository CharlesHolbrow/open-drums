import * as cybr from './cybr';
import { FluidTrack, TrackConfig } from './FluidTrack';
import { ScoreConfig, Event } from './fluid-interfaces';
export interface SessionConfig extends ScoreConfig {
    /** Beats per minute */
    bpm?: number;
    /** Looping is disabled by default unless you specify a `loopStartTime` */
    loopEnabled?: boolean;
    /** Loop region start time, specified in whole notes */
    loopStartTime?: number;
    /**
     * Loop region duration, specified in whole notes. Automatically enables
     * looping unless `loopEnabled: false` is explicit
     * */
    loopDuration?: number;
}
export declare class FluidSession {
    constructor(session: SessionConfig, tracks?: TrackConfig[]);
    scoreConfig: ScoreConfig;
    bpm: number;
    tracks: FluidTrack[];
    regions: any[];
    /** Position of the edit cursor, measured in whole notes */
    editCursorTime: number;
    /** Loop region, measured in whole notes */
    loopRegion: Event;
    loopEnabled: boolean;
    /**
     * Recursively iterate over all tracks, including track folders and their
     * children, passing each track in to the supplied function as the first
     * argument. If the supplied function returns anything other than `undefined`,
     * the iteration is interrupted, and forEachTrack will return the value
     * returned by `func`.
     *
     * Note that iteration will be interrupted when `func` returns ANY value
     * other than `undefined`. This includes falsy values like `null` and `0`.
     *
     * IMPORTANT: This iterates over the underlying arrays directly, so you
     * should not add or remove tracks to the session during iteration.
     *
     * @param func for each track, func will be called with three arguments:
     *    (1) a `FluidTrack`
     *    (2) an index which specifies the position of the track within
     *    its immediate parent
     *    (3) a 'ancestors' array, which contains the track's parent, (and its
     *    parent's parent, etc) starting with the 'oldest' grandparent, and ending
     *    with the tracks immediate parent.
     */
    forEachTrack<T>(func: {
        (track: FluidTrack, index: number, ancestors: FluidTrack[]): T;
    }): T | undefined;
    getTrackByName(name: string): FluidTrack | null;
    getOrCreateTrackByName(name: string): FluidTrack;
    /**
     * Find a track by name, returning that track and all of its ancestors in an
     * array. The first track in the array will always be a track at the root
     * level of the session. Every track in the array *except for the last one*,
     * is guaranteed to be a track folder (meaning its `.children.length` property
     * will be non-zero).
     *
     * If the track is not found, it will be created at the root level, and
     * returned in an array with `.length == 1`.
     * @param name
     */
    getOrCreateTrackAncestorsByName(name: string): FluidTrack[];
    /**
     * Insert a score object into the session.
     *
     * The contents of the score will be inserted at `session.editCursorTime`,
     * unless a `config.startTime` is specified.
     *
     * Inserting moves `session.editCursorTime` to the end of newly inserted
     * content. (When no `config.startTime` is specified, calling `insertScore`
     * multiple times inserts contents sequentially)
     * @chainable
     */
    insertScore(score: any, config?: ScoreConfig): this;
    /**
     * Iterate over the tracks, and resolve any unresolved sends. This is used
     * internally by [[FluidSession.constructor]]. It does not need to be called
     * by consuming code unless you manually add tracks with unresolved sends to
     * [[FluidSession.tracks]].
     *
     * Sends are specified on sending tracks, but stored in receiving tracks. This
     * makes it easy to delete a track without having to go hunt down all the
     * tracks that send to it.
     * @internal
     */
    resolveSends(): void;
    /**
     * Iterate over track's plugins, and resolve sidechain receives. This is used
     * internally by [[FluidSession.constructor]]. It does not need to be called
     * from consuming code unless you manually add unresolved sidechain receives
     * to a new or existing track plugin.
     * @internal
     */
    resolveSidechainReceives(): void;
    timeWholeNotesToSeconds(timeInWholeNotes: number): number;
    timeSecondsToWholeNotes(timeInSeconds: number): number;
    /**
     * Iterate over tracks and their clips, calling each technique's
     * `.use(context)` method.
     *
     * This is called internally by [[FluidSession.insertScore]], and does not
     * need to be called by consuming code.
     * @internal
     */
    processEvents(): void;
    finalize(): this;
    /**
     * Create a .tracktionedit file from the session. The `cybr` server must be
     * running when this is called.
     *
     * WARNING: sessionToTracktionEdit may not be called simultaneously with other
     * methods that access the cybr server. Use `await` or `.then` to make sure that
     * this method finishes before using communicating with the server
     *
     * @param filename can be absolute or relative to the working directory. The
     *    `.tracktionedit` file extension will be added if it is not present
     * @param client an [[IpcClient]] will be created (and closed) automatically
     *    when not provided. When you do provide a client, that client must be
     *    configured with `keepOpen=true`.
     */
    saveAsTracktionFile(filename?: string, client?: cybr.IpcClient): Promise<void>;
    /**
     * Send the entire session to the cybr server. If the server already has an
     * active session, it will be replaced by this session.
     *
     * @param filename can be absolute or relative to the working directory. The
     *    `.tracktionedit`. This file extension will be added if it is not present
     * @param client an [[IpcClient]] will be created (and closed) automatically
     *    when not provided. When you do provide a client, that client must be
     *    configured with `keepOpen=true`.
     */
    sendToServer(filename?: string, client?: cybr.IpcClient): Promise<void>;
    /**
     * Save the session as a [Reaper](https://reaper.fm) `.RPP` file. If the
     * session contains any VST plugins, the `cybr` server must be running (and
     * it must be compiled with VST support).
     * @param filename can be absolute or relative to the working directory. The
     *    `.RPP` file extension will be added if it is not already present.
     * @param client an [[IpcClient]] will be created (and closed) automatically
     *    when not provided
     */
    saveAsReaperFile(filename?: string, client?: cybr.IpcClient): Promise<void>;
}
/**
 * Parse descends through a Score Object, and creates clips for every pattern
 * string in a child object. These clips will be added to their parent track,
 * on the supplied session. It is used internally by
 * [[FluidSession.insertScore]].
 *
 * Note that the clips will not be ready for use: All events will be placed in
 * the clip.events member. `session.processEvents` moves the events to their
 * final homes.
 * @internal
 */
export declare function parse(scoreObject: any, session?: FluidSession, config?: ScoreConfig): {
    duration: number;
    startTime: number;
};
