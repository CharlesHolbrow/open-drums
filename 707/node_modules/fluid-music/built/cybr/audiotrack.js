"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeAutomation = exports.removeClips = exports.renderRegion = exports.width = exports.pan = exports.gain = exports.unmute = exports.mute = exports.send = exports.selectSubmixTrack = exports.selectReturnTrack = exports.insertWav = exports.select = void 0;
/**
 * Select an audio track by name
 * @param {string} trackName
 */
function select(trackName, parent) {
    if (typeof trackName !== 'string')
        throw new Error('audiotrack.Select requires track name string, got: ' + trackName);
    const args = [{ type: 'string', value: trackName }];
    if (typeof parent === 'string')
        args.push({ type: 'string', value: parent });
    return { address: '/audiotrack/select', args };
}
exports.select = select;
/**
 * Insert and select an audio file clip into the selected audio track. Noop
 * when there is no selected track.
 * @param {string} clipName name the new clip
 * @param {number} startTimeInWholeNotes clip start time in quarter notes
 * @param {string} fileName
 */
function insertWav(clipName, startTimeInWholeNotes, fileName) {
    if (typeof clipName !== 'string')
        throw new Error('audiotrack.insertWav: clipName must be a string');
    if (typeof startTimeInWholeNotes !== 'number')
        throw new Error('audiotrack.insertWav: start time must be a number');
    if (typeof fileName !== 'string')
        throw new Error('audiotrack.insertWav: fileName must be a string');
    const args = [
        { type: 'string', value: clipName },
        { type: 'string', value: fileName },
        { type: 'float', value: startTimeInWholeNotes },
    ];
    return { address: '/audiotrack/insert/wav', args };
}
exports.insertWav = insertWav;
/**
 * Selects a track, ensuring that it has a bus return. Afterwords, other
 * tracks can add sends that target the track selected with this method.
 *
 * Use the audiotrack.send method to send from other tracks to a return.
 *
 * @param {string} busName - name of audiotrack (the return will be named
 *                           after the audio track).
 */
function selectReturnTrack(busName) {
    if (typeof busName !== 'string')
        throw new Error('selectReturnTrack requires track name string, got: ' + busName);
    const args = [{ type: 'string', value: busName }];
    return { address: '/audiotrack/select/return', args };
}
exports.selectReturnTrack = selectReturnTrack;
function selectSubmixTrack(name, parent) {
    if (typeof name !== 'string')
        throw new Error('selectSubmixTrack requires a name string');
    const args = [{ type: 'string', value: name }];
    if (typeof parent === 'string')
        args.push({ type: 'string', value: parent });
    return { address: '/audiotrack/select/submix', args };
}
exports.selectSubmixTrack = selectSubmixTrack;
/**
 * Adjust the send level to the specified bus, adding the send (post-gain) if
 * it does not yet exist. Use with audiotrack.selectReturnTrack(busName).
 * @param {string} busName The name of the return bus to send to
 * @param {number} [levelDb=0] default on the server is 0
 */
function send(busName, levelDb) {
    if (typeof busName !== 'string')
        throw new Error('send requires track name string, got: ' + busName);
    if (typeof levelDb !== undefined && typeof levelDb !== 'number')
        throw new Error('if send has a levelDb, it must be a number');
    const args = [
        { type: 'string', value: busName },
        { type: 'string', value: 'ignored' },
        { type: 'string', value: 'post-gain' },
    ];
    if (typeof levelDb === 'number')
        args[1] = { type: 'float', value: levelDb };
    return { address: '/audiotrack/send/set/db', args };
}
exports.send = send;
/**
 * Mute or unmute the selected audio track.
 * @param {boolean} [mute=true] true if track should be muted. false = unmute.
 */
function mute(mute = true) {
    if (mute)
        return { address: '/audiotrack/mute' };
    else
        return { address: '/audiotrack/unmute' };
}
exports.mute = mute;
/**
 * Unmute the selected audio track.
 */
function unmute() {
    return { address: '/audiotrack/unmute' };
}
exports.unmute = unmute;
/**
 * Adjust the track gain or add a gain automation point.
 *
 * When adjusting gain, set the gain of the the last volume plugin on the
 * track's PluginList. When adding volume automation, adjust the second last
 * volume parameter, creating it if needed.
 * @param {number} dbfs
 * @param startTimeInWholeNotes When present, insert an automation point instead
 *    of setting the parameter directly
 * @param curve (default) 0=linear, -1=startFast, 1=startSlow
 */
function gain(dbfs, startTimeInWholeNotes, curve) {
    if (typeof dbfs !== 'number')
        throw new Error('audiotrack.gain requires a number in dbfs');
    const args = [{ type: 'float', value: dbfs }];
    if (typeof startTimeInWholeNotes === 'number') {
        args.push({ type: 'float', value: startTimeInWholeNotes });
        if (typeof curve === 'number') {
            args.push({ type: 'float', value: curve });
        }
    }
    return { address: '/audiotrack/set/db', args };
}
exports.gain = gain;
/**
 * Set the pan, or add a pan automation point
 * @param bipolar stereo pan position -1=hardLeft, 1=hardRight
 * @param startTimeInWholeNotes When present, insert an automation point instead
 *    of setting the parameter directly
 * @param curve (default) 0=linear, -1=startFast, 1=startSlow
 */
function pan(bipolar, startTimeInWholeNotes, curve) {
    if (typeof bipolar !== 'number')
        throw new Error('audiotrack.pan requires a number');
    const args = [{ type: 'float', value: Math.max(Math.min(bipolar, 1), -1) }];
    if (typeof startTimeInWholeNotes === 'number') {
        args.push({ type: 'float', value: startTimeInWholeNotes });
        if (typeof curve === 'number') {
            args.push({ type: 'float', value: curve });
        }
    }
    return { address: '/audiotrack/set/pan', args };
}
exports.pan = pan;
/**
 * Set the track width, or add a width automation point
 * @param bipolar 1=default, 0=mono, -1=stereoInvert
 * @param startTimeInWholeNotes When present, insert an automation point instead
 *    of setting the parameter directly
 * @param curve (default) 0=linear, -1=startFast, 1=startSlow
 */
function width(bipolar, startTimeInWholeNotes, curve) {
    const args = [{ type: 'float', value: Math.max(Math.min(bipolar, 1), -1) }];
    if (typeof startTimeInWholeNotes === 'number') {
        args.push({ type: 'float', value: startTimeInWholeNotes });
        if (typeof curve === 'number') {
            args.push({ type: 'float', value: curve });
        }
    }
    return { address: '/audiotrack/set/width', args };
}
exports.width = width;
/**
 * Render a region of the track to an audio file. If no time range is
 * supplied, the engine should use the loop time range.
 *
 * @param {string} outFilename output filename
 * @param {number} [startTimeInWholeNotes] start time in whole notes
 * @param {number} [durationInWholeNotes] duration in whole notes
 */
function renderRegion(outFilename, startTimeInWholeNotes, durationInWholeNotes) {
    if (typeof outFilename !== 'string')
        throw new Error('audiotrack.renderRegion requires a outputFilename string');
    const args = [{ type: 'string', value: outFilename }];
    if (startTimeInWholeNotes !== undefined || durationInWholeNotes !== undefined) {
        if (typeof startTimeInWholeNotes !== 'number' ||
            typeof durationInWholeNotes !== 'number') {
            const msg = 'An invalid time range was supplied to renderRegion: ' +
                'Both start and duration values must be numbers.';
            throw new Error(msg);
        }
    }
    if (typeof startTimeInWholeNotes === 'number') {
        args.push({ type: 'float', value: startTimeInWholeNotes });
        args.push({ type: 'float', value: durationInWholeNotes });
    }
    return { args, address: '/audiotrack/region/render' };
}
exports.renderRegion = renderRegion;
/**
 * Remove all clips (ex. audio, midi clips) from the selected audio track.
 */
function removeClips() {
    return { address: '/audiotrack/remove/clips' };
}
exports.removeClips = removeClips;
/**
 * Remove all automation from the track and from all the tracks plugins.
 */
function removeAutomation() {
    return { address: '/audiotrack/remove/automation' };
}
exports.removeAutomation = removeAutomation;
//# sourceMappingURL=audiotrack.js.map