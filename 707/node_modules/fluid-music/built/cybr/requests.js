"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestReport = void 0;
const audiotrack = require("./audiotrack");
const plugin = require("./plugin");
const IpcClient_1 = require("./IpcClient");
/**
 * @param pluginName The plugin name (see cybr.plugin.select)
 * @param pluginType The plugin type (see cybr.plugin.select)
 * @param trackName The track name to create the plugin on
 * @param nth Index (if there are multiple plugins of the same kind on the
 *    track - see cybr.plugin.select)
 * @param extraMessages cybr messages to configure plugin parameters
 * @param client the cybr client use to retrieve plugin state
 * @param pauseMs the duration to wait between setting the plugin parameters, and
 *    retrieving the state. Some plugins do not report their state immediately
 */
function requestReport(pluginName, pluginType, trackName = 'plugin-helper-track', nth = 0, extraMessages = [], client = new IpcClient_1.IpcClient({}), pauseMs = 120) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (!(client instanceof IpcClient_1.IpcClient))
            throw new Error('cybr.requests.requestReport was not passed an IpcClient instance');
        const msg1 = [
            audiotrack.select(trackName),
            plugin.select(pluginName, pluginType, nth),
            ...extraMessages
        ];
        const msg2 = [
            audiotrack.select(trackName),
            plugin.select(pluginName, pluginType, nth),
            plugin.getReport(),
        ];
        yield client.send(msg1);
        yield new Promise(resolve => setTimeout(resolve, pauseMs));
        const result2 = yield client.send(msg2);
        // result2 is a osc-min bundle with a .elements array. The elements array
        // should contain one osc-min message for each object in msg2. If the request
        // was successful, a JSON string will be in result2.elements[2].args[2].value)
        const pluginReportOscArgs = (_a = result2 === null || result2 === void 0 ? void 0 : result2.elements[2]) === null || _a === void 0 ? void 0 : _a.args;
        if (!Array.isArray(pluginReportOscArgs)) {
            console.error(result2);
            throw new Error('cybr.requests.requestReport received invalid OSC response');
        }
        let [errorCode, errorString, jsonString] = pluginReportOscArgs;
        const makeError = (reason) => new Error(`cybr.requests.requestReport ${reason}
plugin name: ${pluginName}
plugin type: ${pluginType}
server msg:  ${errorString.value}\n`);
        if (errorCode.value)
            throw makeError(`failed to get a plugin report.
Are you sure the ${pluginName} (${pluginType}) plugin is installed?
Try '$ cybr --scan-plugins' and '$ cybr --list-plugins'`);
        try {
            return JSON.parse(jsonString.value);
        }
        catch (_b) {
            throw makeError('received invalid json from the server');
        }
    });
}
exports.requestReport = requestReport;
//# sourceMappingURL=requests.js.map