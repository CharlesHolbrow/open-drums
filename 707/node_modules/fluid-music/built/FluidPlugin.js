"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FluidPlugin = exports.PluginType = exports.map = exports.linear = void 0;
exports.linear = (min, max) => (v) => (v - min) / (max - min);
exports.map = (v, min, max) => exports.linear(min, max)(v);
const FluidTrack_1 = require("./FluidTrack");
var PluginType;
(function (PluginType) {
    PluginType["unknown"] = "unknown";
    PluginType["VST2"] = "VST2";
    PluginType["VST3"] = "VST3";
    PluginType["tracktion"] = "tracktion";
    PluginType["AudioUnit"] = "AudioUnit";
})(PluginType = exports.PluginType || (exports.PluginType = {}));
class FluidPlugin {
    constructor(pluginName, pluginType) {
        this.pluginName = pluginName;
        this.pluginType = pluginType;
        this.parameters = {};
        this.parameterLibrary = {};
        this.automation = {};
        this.makeAutomation = {};
    }
    /**
     * If paramKey identifies a plugin parameter, and that parameter has a
     * normalizer, return the normalized value. Otherwise return null.
     */
    getNormalizedValue(paramKey, value) {
        if (this.parameterLibrary.hasOwnProperty(paramKey)) {
            const param = this.parameterLibrary[paramKey];
            if (param.isLinear && param.range) {
                return exports.map(value, param.range[0], param.range[1]);
            }
            if (typeof param.powerFuncB === 'number' && param.range) {
                const [start, end] = param.range;
                return Math.pow((value - start) / (end - start), 1 / param.powerFuncB);
            }
            // NOTE: when adding normalization options, remember to update the plugin
            // generator if needed. It can make better key names for parameters with
            // known normalizers by adding the units: For example, "attackMS" instead
            // "attack" or "gainDb" instead of "gain".
            if (param.normalize) {
                return param.normalize(value);
            }
        }
        return null;
    }
    /**
     * fluid-music has two ways of identifying a parameter with a string:
     * 1. The javascript friendly "key" (ex: `lfo1Speed`)
     * 2. JUCE's parameter name (ex: `LFO 1: Speed`)
     *
     * This function attempts to get JUCE's name from the key. If the key is not
     * registered on the plugin, just return the `key` argument directly. This
     * behavior is designed to make it possible to use and configure plugins with
     * the FludPlugin base class even when there is no adapter available.
     *
     * When there is no adapter available, you can just set a parameter directly:
     * `pluginInstance.parameters["Wet Level"] = 0.8;
     *
     * @param paramKey the JavaScript friendly parameter identifier
     */
    getParameterName(paramKey) {
        return (this.parameterLibrary.hasOwnProperty(paramKey))
            ? this.parameterLibrary[paramKey].name
            : paramKey;
    }
    /**
     * VST2 parameters can also be identified by an index. This method returns the
     * index, or returns null if the index is not available.
     *
     * @param paramKey the JavaScript friendly parameter identifier
     */
    getParameterIndex(paramKey) {
        if (this.parameterLibrary.hasOwnProperty(paramKey)) {
            const param = this.parameterLibrary[paramKey];
            if (typeof param.index === 'number') {
                return param.index;
            }
        }
        return null;
    }
    /**
     * Specify a sidechain input to the plugin.
     *
     * If the first argument is a name string (not a Track Object), the sidechain
     * routing will be unresolved. To resolve the routing, insert the plugin into
     * a track, and call `.resolveSidechainReceives` on the parent session.
     *
     * `sidechainWith` returns the plugin itself, so you can setup a sidechain
     * compressor like this:
     *
     * ```javascript
     * const session = new FluidSession({}, [
     *  { name: 'kick' },
     *  { name: 'bass', plugins: [compressor.sidechainFrom('kick')]}
     * ])
     * ```
     * Note that sidechains are resolved by the FluidSession constructor, so in
     * the example above, a call to `session.resolveSidechainReceives()` is not
     * necessary.
     *
     * @param track name of the track that will feed the sidechain
     */
    sidechainWith(track) {
        if (typeof track === 'string') {
            this.unresolvedSidechainReceive = { from: track };
        }
        else if (track instanceof FluidTrack_1.FluidTrack) {
            this.sidechainReceive = new FluidTrack_1.FluidReceive({ from: track });
        }
        else {
            throw new Error(`sidechainWith received an invalid track: ${track}`);
        }
        return this;
    }
}
exports.FluidPlugin = FluidPlugin;
FluidPlugin.PluginType = PluginType;
//# sourceMappingURL=FluidPlugin.js.map