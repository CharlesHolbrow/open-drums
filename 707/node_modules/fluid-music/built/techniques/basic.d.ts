import { Technique, UseContext } from '../fluid-interfaces';
export interface TechniqueClass {
    new (...options: any[]): Technique;
}
export interface PluginAutoTechniqueClass extends TechniqueClass {
    new (options: PluginAutoOptions): Technique;
}
/**
 * A midi note within a midi clip.
 */
export declare class MidiNote implements Technique {
    constructor(options: MidiNoteOptions);
    /**
     * Midi note number: 60 == C4 == Middle C
     */
    note: number;
    /**
     * If present, velocity overrides a velocity found in a .d object
     */
    velocity?: number;
    use(context: UseContext): null;
}
export interface MidiNoteOptions {
    note: number;
    velocity?: number;
    n?: number;
    v?: number;
}
/**
 * Inserts an automation point for a specific plugin on an arbitrary track
 */
export declare class PluginAutomation implements Technique {
    constructor(options: PluginAutoOptions);
    pluginSelector: PluginSelector;
    paramKey: string;
    value: number;
    curve: number;
    use({ track, startTime }: UseContext): null;
}
export interface PluginAutoOptions extends AutoOptions {
    pluginSelector: PluginSelector;
}
/**
 * Identifies a plugin on an arbitrary track
 */
export interface PluginSelector {
    pluginName: string;
    /** ex: 'VST2', 'VST3', 'AudioUnit' */
    pluginType: string;
    /**
     * The selected track may have multiple plugins with the same name. Index from
     * within those plugins. Most of the time this isn't needed, because it is
     * unusual to have more than one plugin with the same name on a particular
     * track.
     */
    nth?: number;
}
/**
 * An automation event on a track
 */
export declare class TrackAutomation implements Technique {
    paramKey: string;
    value: number;
    curve: number;
    constructor(options: AutoOptions);
    use({ startTime, track }: UseContext): null;
}
export interface AutoOptions {
    paramKey: string;
    value?: number;
    curve?: number;
}
export declare class MidiChord implements Technique {
    notes: number[];
    name: string;
    constructor(options: MidiChordOptions);
    use(context: UseContext): void;
}
export interface MidiChordOptions {
    name?: string;
    notes: number[];
}
/**
 * For samples that have "Intensity Layers," meaning recordings that were
 * sampled at successive increasing performance intensities
 */
export declare class ILayers implements Technique {
    layers: Technique[];
    constructor(options: ILayersOptions);
    use(context: UseContext): void;
    static clamp(min: number, max: number, value: number): number;
}
export interface ILayersOptions {
    layers: Technique[];
}
/**
 * Randomly chooses a technique from an array of choices
 */
export declare class Random implements Technique {
    choices: Technique[];
    constructor(options: RandomOptions);
    use(context: UseContext): any;
}
export interface RandomOptions {
    choices: Technique[];
}
