"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Random = exports.ILayers = exports.MidiChord = exports.TrackAutomation = exports.PluginAutomation = exports.MidiNote = void 0;
const random = require("../random");
/**
 * A midi note within a midi clip.
 */
class MidiNote {
    constructor(options) {
        // For backwards compatibility
        if (typeof options.n === 'number' && typeof options.note !== 'number')
            options.note = options.n;
        if (typeof options.v === 'number' && typeof options.velocity !== 'number')
            options.velocity = options.v;
        this.note = options.note;
        if (typeof options.velocity === 'number')
            this.velocity = options.velocity;
    }
    use(context) {
        if (!context.clip)
            throw new Error('Cannot .use MidiNote without a clip: ' + JSON.stringify({ note: this, context }));
        const { d, startTime, clip, duration } = context;
        const midiNoteEvent = {
            startTime: startTime - clip.startTime,
            duration,
            note: this.note,
            velocity: 64
        };
        if (typeof this.velocity === 'number')
            midiNoteEvent.velocity = this.velocity;
        else if (typeof d.velocity === 'number')
            midiNoteEvent.velocity = d.velocity;
        else if (typeof d.v === 'number')
            midiNoteEvent.velocity = d.v;
        clip.midiEvents.push(midiNoteEvent);
        return null;
    }
}
exports.MidiNote = MidiNote;
/**
 * Inserts an automation point for a specific plugin on an arbitrary track
 */
class PluginAutomation {
    constructor(options) {
        // members with default values
        this.value = 0;
        this.curve = 0;
        if (!options.pluginSelector)
            throw new Error('Cannot create PluginAuto technique without .pluginSelector');
        this.pluginSelector = Object.assign({}, options.pluginSelector);
        this.paramKey = options.paramKey; // ex: 'sizeMeters'
        if (typeof options.value === 'number')
            this.value = options.value;
        if (typeof options.curve === 'number')
            this.curve = options.curve;
    }
    use({ track, startTime }) {
        const point = {
            startTime,
            value: this.value,
            curve: this.curve,
        };
        const nth = this.pluginSelector.nth || 0;
        const matches = track.plugins.filter(plugin => plugin.pluginName === this.pluginSelector.pluginName &&
            plugin.pluginType === this.pluginSelector.pluginType);
        if (nth >= matches.length) {
            const needed = nth - matches.length + 1;
            if (needed > 0)
                throw new Error(`${needed} missing ${this.pluginSelector.pluginName} plugins of on ${track.name} track`);
        }
        const plugin = matches[nth];
        const automation = plugin.automation;
        if (!automation.hasOwnProperty(this.paramKey))
            automation[this.paramKey] = { points: [] };
        automation[this.paramKey].points.push(point);
        return null;
    }
}
exports.PluginAutomation = PluginAutomation;
/**
 * An automation event on a track
 */
class TrackAutomation {
    constructor(options) {
        this.value = 0;
        this.curve = 0;
        this.paramKey = options.paramKey;
        if (typeof options.paramKey !== 'string')
            throw new Error('TrackAutomation constructor missing paramKey:' + JSON.stringify(options));
        if (typeof options.value === 'number')
            this.value = options.value;
        if (typeof options.curve === 'number')
            this.curve = options.curve;
    }
    use({ startTime, track }) {
        const point = {
            startTime,
            value: this.value,
            curve: 0,
        };
        if (typeof this.curve === 'number')
            point.curve = this.curve;
        const automation = track.automation;
        if (!automation.hasOwnProperty(this.paramKey))
            automation[this.paramKey] = { points: [] };
        automation[this.paramKey].points.push(point);
        return null;
    }
}
exports.TrackAutomation = TrackAutomation;
class MidiChord {
    constructor(options) {
        this.name = 'midi chord';
        this.notes = options.notes;
        if (typeof options.name === 'string')
            this.name = options.name;
    }
    use(context) {
        for (const note of this.notes) {
            const midiNote = new MidiNote({ note });
            midiNote.use(context);
        }
    }
}
exports.MidiChord = MidiChord;
/**
 * For samples that have "Intensity Layers," meaning recordings that were
 * sampled at successive increasing performance intensities
 */
class ILayers {
    constructor(options) {
        this.layers = options.layers;
    }
    use(context) {
        let length = this.layers.length; // number of layers
        let index = length - 1; // default to last layer
        let d = Object.assign({}, context.d);
        // Look for an intensity
        if (typeof d.intensity === 'number') {
            index = Math.floor(d.intensity * length);
        }
        // If no intensity was found, look for a velocity
        else if (typeof d.velocity === 'number') {
            index = Math.floor(d.velocity / (127 / this.layers.length));
        }
        else if (typeof d.v === 'number') {
            index = Math.floor(d.v / (127 / this.layers.length));
        }
        const technique = this.layers[ILayers.clamp(0, length - 1, index)];
        technique.use(context);
    }
    static clamp(min, max, value) {
        if (min > max)
            [min, max] = [max, min];
        return Math.max(Math.min(value, max), min);
    }
}
exports.ILayers = ILayers;
/**
 * Randomly chooses a technique from an array of choices
 */
class Random {
    constructor(options) {
        if (options.choices.length < 1) {
            throw new Error('Random Technique needs at least one choice');
        }
        for (const choice of options.choices) {
            if (typeof choice.use !== 'function') {
                throw new Error('Random Technique got an invalid choice: ' + JSON.stringify(choice));
            }
        }
        this.choices = options.choices;
    }
    use(context) {
        const technique = random.choice(this.choices);
        return technique.use(context);
    }
}
exports.Random = Random;
//# sourceMappingURL=basic.js.map