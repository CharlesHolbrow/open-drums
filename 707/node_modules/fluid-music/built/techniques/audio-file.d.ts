import { AudioFileConfig, FluidAudioFile, AudioFileOptions } from '../FluidAudioFile';
import { Technique, UseContext } from '../fluid-interfaces';
/**
 * Insert an audio sample into a track.
 *
 * Note that base class [[`FluidAudioFile`]] has many useful methods and
 * properties for trimming, fading, reversing, etc.
 */
export declare class AudioFile extends FluidAudioFile implements Technique {
    use({ track, startTimeSeconds, durationSeconds, d }: UseContext): FluidAudioFile;
    /**
     * Create a copy of an `AudioFile` technique, optionally applying changes to
     * the copy before returning it. This is useful in situations when you want
     * variations of an audioFile with different properties.
     *
     * Note that the value returned will be an `AudioFile` even if the first
     * argument is an instance of a class derived from `AudioFile`. As a result,
     * the output object will not be an exact copy if `audioFileTechnique` is
     * derived from `techniques.AudioFile`.
     *
     * `const newAudioFile = AudioFile.copy(someAudioFile)`
     *
     * @param audioFileTechnique The input `AudioFile` technique to copy
     * @param change The resulting `AudioFile` will
     * @returns A copied version of the input audio file technique
     */
    static copy(audioFileTechnique: AudioFile | AudioFileOptions, change?: AudioFileConfig): AudioFile;
}
/**
 * AFOnset (Audio File Onset) encapsulates a `techniques.AudioFile` instance,
 * dividing the underlying source audio file into three regions delimited by
 * `onsetSeconds` and `releaseSeconds`.
 *
 * ```
 *       onsetSeconds
 * ├──────────┘         releaseSeconds
 * ├───────────────────────────┘
 * ├──attack──┼──────body──────┼─────────decay─────────┤
 * ```
 *
 * Using this technique in a score shifts the resulting audio item to the left
 * on the timeline such that the audio file onset coincides with the the start
 * of the event. This is useful for audio samples that have an "appoggiatura"
 * that "leads in" to the musical onset of the sample.
 */
export declare class AFOnset {
    audioFile: AudioFile;
    /**
     * @param {AudioFile} audioFileTechnique
     * @param {number} [onsetSeconds] The time at which the 'onset' portion of the
     *    sound begins, measured from the start of the source audio file. If not
     *    provided, use the underlying `onset` marker in the source audio file. If
     *    there is no `onset` marker, use 0 (the start of the file)
     * @param {number} [releaseSeconds] The time at which the 'release' portion of
     *    the sound begins, measured from the start of the source audio file. If
     *    not provided, use the `release` marker in the source audio file. If
     *    there is no `release` marker, use the end of the underlying audio file.
     */
    constructor(audioFileTechnique: AudioFile, onsetSeconds?: number, releaseSeconds?: number);
    use(context: UseContext): AudioFile;
    /**
     * Time at which the sample's "body" begins, relative to the start of the
     * source audio file.
     */
    get onsetSeconds(): number;
    set onsetSeconds(seconds: number);
    /**
     * Time at which the sample's "decay" begins, relative to the start of the
     * source audio file.
     */
    get releaseSeconds(): number;
    set releaseSeconds(seconds: number);
}
export declare class AFReverse extends AFOnset implements Technique {
    use(context: UseContext): AudioFile;
}
export declare class AFReverseLeadIn extends AFOnset implements Technique {
    use(context: UseContext): AudioFile;
}
