import { guess } from './cybr/plugin-report-utils'
import { makeVarName, camelCaseFromParamName, upperFirstLetter } from './plugin-generator-name-helpers'

/**
 * Create a plugin adapter Typescript module from a plugin report
 * @param report A plugin report object generated by cybr. Step size must be odd
 * @param className Optionally override the pluginName supplied in the report
 */
export function generatePluginModule(report : any, config : {className?: string, extraMethods?: string} = {}) {
  const pluginName = report.pluginName
  const pluginType = {
    'VST': 'PluginType.VST2',
    'VST2': 'PluginType.VST2',
    'VST3': 'PluginType.VST3'
  }[report.pluginType]
  const pluginTypeExt = upperFirstLetter(pluginType.split('.')[1].toLowerCase()) // Vst2
  const className = typeof config.className === 'string' ? config.className : makeVarName(pluginName) + pluginTypeExt // DragonflyRoomVst2
  const parametersInterfaceName = className + 'Parameters'; // DragonflyRoomVst2Parameters

  // remove the "Dry Level" "Wet Level" params that tracktion adds
  const params = report.params.slice(2)
  params.forEach(paramInfo => {
    if (!paramInfo.hasOwnProperty('guess')) paramInfo.guess = guess(paramInfo)
    if (!paramInfo.hasOwnProperty('index')) paramInfo.index = paramInfo.tracktionIndex - 2

    // Assume guesses are correct iff the underlying object does not specify
    for (const k of Object.keys(paramInfo.guess)) {
      if (!paramInfo.hasOwnProperty(k)) paramInfo[k] = paramInfo.guess[k]
    }

    // If we have a normalizer we can make a better key by adding units
    if (!paramInfo.hasOwnProperty('key')) {
      paramInfo.key = camelCaseFromParamName(paramInfo.name)
      if (paramInfo.units && (paramInfo.isLinear || typeof paramInfo.powerFuncB === 'number')) {
        paramInfo.key += upperFirstLetter(paramInfo.units)
      }
    }
  })

  let output = `import { PluginType, FluidPlugin } from '../FluidPlugin';
import { PluginAutomation } from '../techniques';
const pluginName = '${pluginName}'
const pluginType = ${pluginType}

export interface ${parametersInterfaceName} {
`
  // For now, assume that every parameter is a number. This may change.
  output += params.map(param => {
    let result = ''
    if (param.range) result += `  /** ${param.units ? param.units+' ' : ''}value from ${param.range[0]} to ${param.range[1]} */\n`
    result += `  ${param.key}? : number;`
    return result
  }).join('\n') + '\n}\n'

  // Create the parameterLibrary
  output += 'const parameterLibrary = {\n'
  output += params.map(param => {
    let result = `  ${param.key}: { name: '${param.name}', index: ${param.index}, isLinear: ${!!param.isLinear}`
    if (param.range) result += `, range: [${param.range[0]}, ${param.range[1]}] as [number, number]`
    if (param.units) result += `, units: '${param.units}'`
    if (typeof param.powerFuncB === 'number') result += `, powerFuncB: ${param.powerFuncB}`
    if (param.choices) result += `, choices: ${JSON.stringify(param.choices)}`
    if (param.normalizeFunctionAsString) result += `,
    normalize: ${param.normalizeFunctionAsString}`
    return result + ' }'
  }).join(',\n') + '\n}\n'

  // makeAutomation includes the helpers for creating automation points
  output += 'const makeAutomation = {\n'
  output += params.map(paramInfo => {
    return `  ${paramInfo.key} (value? : number, curve = 0) {
    return new PluginAutomation({
      value,
      curve,
      pluginSelector: { pluginName, pluginType },
      paramKey: '${paramInfo.key}',
    });
  }`
  }).join(',\n') + '\n}\n'

  // Finally create the class itself
  output += `export class ${className} extends FluidPlugin {
  constructor(
    public readonly parameters : ${parametersInterfaceName} = {},
  ) { super(pluginName, pluginType) }

  readonly parameterLibrary = parameterLibrary;
  readonly makeAutomation = makeAutomation;

  // Static members
  static readonly parameterLibrary = parameterLibrary;
  static readonly makeAutomation = makeAutomation;
${config.extraMethods || ''}}
`

  return output
}
